"""
报告生成API路由
"""
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import Optional
import logging
import sys
import os
import time

# 添加backend目录到Python路径
backend_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'backend')
if backend_dir not in sys.path:
    sys.path.insert(0, backend_dir)

logger = logging.getLogger(__name__)
router = APIRouter()


class GenerateRequest(BaseModel):
    """生成请求"""
    query: str
    data_source: Optional[str] = None
    analysis_type: Optional[str] = None


class GenerateResponse(BaseModel):
    """生成响应"""
    cards: dict
    report: dict
    execution_time: float


@router.post("/cards")
async def generate_cards(request: GenerateRequest):
    """
    生成四色卡片（使用NPU推理）

    从backend导入NPU推理功能，生成真实的四色卡片

    参数：
        request: 生成请求

    返回：
        四色卡片
    """
    try:
        start_time = time.time()

        # 从backend导入模型加载器和推理函数
        try:
            from models.model_loader import get_model_loader, load_model_if_needed
            from main import real_inference
        except ImportError as e:
            logger.error(f"无法导入backend的NPU推理模块: {e}")
            raise HTTPException(
                status_code=503,
                detail=f"NPU推理模块不可用: {str(e)}"
            )

        # 加载模型
        loader = load_model_if_needed()

        if loader is None:
            raise HTTPException(
                status_code=503,
                detail="NPU模型未加载，无法生成卡片"
            )

        # 执行NPU推理
        raw_result = real_inference(request.query, loader)
        inference_time = raw_result.get("inference_time_ms", 0)

        # 构建四色卡片
        cards = {}

        # 蓝色卡片 - 事实
        if raw_result.get("facts"):
            facts = raw_result["facts"]
            if facts:
                cards["blue"] = {
                    "card_type": "blue",
                    "title": "数据事实",
                    "content": {
                        "facts": facts
                    },
                    "confidence": 0.95
                }

        # 绿色卡片 - 解释
        if raw_result.get("explanations"):
            explanations = raw_result["explanations"]
            if explanations:
                cards["green"] = {
                    "card_type": "green",
                    "title": "原因解释",
                    "content": {
                        "explanations": explanations
                    },
                    "confidence": 0.90
                }

        # 黄色卡片 - 风险
        if raw_result.get("risks"):
            risks = raw_result["risks"]
            if risks:
                cards["yellow"] = {
                    "card_type": "yellow",
                    "title": "风险预警",
                    "content": {
                        "risks": risks
                    },
                    "confidence": 0.88
                }

        # 红色卡片 - 行动
        if raw_result.get("actions"):
            actions = raw_result["actions"]
            if actions:
                cards["red"] = {
                    "card_type": "red",
                    "title": "行动建议",
                    "content": {
                        "actions": actions
                    },
                    "confidence": 0.85
                }

        # 如果没有生成任何卡片，返回错误
        if not cards:
            logger.error("NPU推理未能生成有效的四色卡片")
            raise HTTPException(
                status_code=500,
                detail="NPU推理未能生成有效的四色卡片，请检查查询内容"
            )

        execution_time = time.time() - start_time

        logger.info(f"成功生成四色卡片，耗时: {execution_time:.2f}s，NPU推理: {inference_time:.2f}ms")

        return {
            "cards": cards,
            "execution_time": execution_time,
            "inference_time_ms": inference_time,
            "npu_used": True
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"生成卡片失败: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/report")
async def generate_report(request: GenerateRequest):
    """
    生成完整报告

    使用NPU推理生成完整的分析报告

    参数：
        request: 生成请求

    返回：
        完整报告
    """
    try:
        start_time = time.time()

        # 从backend导入NPU推理功能
        try:
            from models.model_loader import get_model_loader, load_model_if_needed
            from main import real_inference
        except ImportError as e:
            logger.error(f"无法导入backend的NPU推理模块: {e}")
            raise HTTPException(
                status_code=503,
                detail=f"NPU推理模块不可用: {str(e)}"
            )

        # 加载模型
        loader = load_model_if_needed()

        if loader is None:
            raise HTTPException(
                status_code=503,
                detail="NPU模型未加载，无法生成报告"
            )

        # 执行NPU推理
        raw_result = real_inference(request.query, loader)
        inference_time = raw_result.get("inference_time_ms", 0)

        # 构建完整报告
        report = {
            "summary": {
                "title": "智能分析报告",
                "description": f"基于NPU推理对以下查询生成的分析结果：{request.query[:100]}{'...' if len(request.query) > 100 else ''}",
                "generated_at": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
                "inference_time_ms": inference_time
            },
            "facts": [],
            "explanations": [],
            "risks": [],
            "actions": []
        }

        # 填充事实
        for fact in raw_result.get("facts", []):
            report["facts"].append({
                "title": "事实",
                "description": fact
            })

        # 填充解释
        for explanation in raw_result.get("explanations", []):
            report["explanations"].append({
                "title": "解释",
                "description": explanation
            })

        # 填充风险
        for risk in raw_result.get("risks", []):
            report["risks"].append({
                "title": "风险",
                "description": risk,
                "level": "高"
            })

        # 填充行动建议
        for action in raw_result.get("actions", []):
            report["actions"].append({
                "title": "行动建议",
                "description": action,
                "priority": "立即执行"
            })

        execution_time = time.time() - start_time

        logger.info(f"成功生成完整报告，耗时: {execution_time:.2f}s")

        return {
            "report": report,
            "execution_time": execution_time,
            "inference_time_ms": inference_time,
            "npu_used": True
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"生成报告失败: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/batch")
async def batch_generate(requests: list):
    """
    批量生成
    
    参数：
        requests: 生成请求列表
    
    返回：
        生成结果列表
    """
    try:
        results = []
        
        for request in requests:
            try:
                result = await generate_cards(request)
                results.append({
                    "query": request.query,
                    "status": "success",
                    "result": result
                })
            except Exception as e:
                results.append({
                    "query": request.query,
                    "status": "failed",
                    "error": str(e)
                })
        
        return {
            "results": results,
            "total": len(requests),
            "success": len([r for r in results if r["status"] == "success"]),
            "failed": len([r for r in results if r["status"] == "failed"])
        }
    
    except Exception as e:
        logger.error(f"批量生成失败: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))
